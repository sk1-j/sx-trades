"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAddress = exports.isPositiveBigNumber = exports.validateINewOrderSchema = exports.validateISignedRelayerMakerOrder = exports.validateIRelayerMakerOrder = exports.validateIFillDetailsMetadata = exports.validateIGetTradesRequest = exports.validateIGetPendingBetsRequest = void 0;
const address_1 = require("@ethersproject/address");
Object.defineProperty(exports, "isAddress", { enumerable: true, get: function () { return address_1.isAddress; } });
const bignumber_1 = require("@ethersproject/bignumber");
const bytes_1 = require("@ethersproject/bytes");
const constants_1 = require("@ethersproject/constants");
const constants_2 = require("../constants");
const convert_1 = require("./convert");
function validateIGetPendingBetsRequest(payload) {
    const { bettor, startDate, endDate, fillHash, baseToken } = payload;
    if (startDate !== undefined && !isNonNegativeInteger(startDate)) {
        return "invalid startDate";
    }
    if (endDate !== undefined && !isNonNegativeInteger(endDate)) {
        return "invalid endDate";
    }
    if (!address_1.isAddress(bettor)) {
        return "invalid bettor";
    }
    if (fillHash !== undefined && !bytes_1.isHexString(fillHash)) {
        return "invalid fillHash";
    }
    if (baseToken !== undefined && !bytes_1.isHexString(baseToken)) {
        return "invalid baseToken";
    }
    return "OK";
}
exports.validateIGetPendingBetsRequest = validateIGetPendingBetsRequest;
function validateIGetTradesRequest(payload) {
    const { startDate, endDate, bettor, settled, marketHashes, baseToken, maker, affiliate, pageSize, paginationKey, } = payload;
    if (startDate !== undefined && !isNonNegativeInteger(startDate)) {
        return "invalid startDate";
    }
    if (endDate !== undefined && !isNonNegativeInteger(endDate)) {
        return "invalid endDate";
    }
    if (startDate !== undefined &&
        endDate !== undefined &&
        startDate >= endDate) {
        return "startDate not before endDate";
    }
    if (bettor !== undefined && !address_1.isAddress(bettor)) {
        return "invalid bettor";
    }
    if (settled !== undefined && typeof settled !== "boolean") {
        return "invalid settled";
    }
    if (maker !== undefined && typeof maker !== "boolean") {
        return "invalid maker";
    }
    if (marketHashes !== undefined && !Array.isArray(marketHashes)) {
        return "invalid marketHashes";
    }
    if (baseToken !== undefined && !address_1.isAddress(baseToken)) {
        return "invalid baseToken";
    }
    if (marketHashes !== undefined &&
        !marketHashes.every((hash) => typeof hash === "string")) {
        return "invalid marketHashes";
    }
    if (affiliate !== undefined && typeof affiliate !== "string") {
        return "invalid affiliate";
    }
    if (pageSize !== undefined && !isNonNegativeInteger(pageSize)) {
        return "invalid pageSize";
    }
    if (paginationKey !== undefined && typeof paginationKey !== "string") {
        return "invalid paginationKey";
    }
    return "OK";
}
exports.validateIGetTradesRequest = validateIGetTradesRequest;
function validateIFillDetailsMetadata(metadata) {
    const { action, market, betting, stake, odds, returning } = metadata;
    if (typeof action !== "string") {
        return "action is not a string";
    }
    if (typeof market !== "string") {
        return "market is not a string";
    }
    if (typeof betting !== "string") {
        return "betting is not a string";
    }
    if (typeof stake !== "string") {
        return "stake is not a string";
    }
    if (typeof odds !== "string") {
        return "odds is not a string";
    }
    if (typeof returning !== "string") {
        return "returning is not a string";
    }
    return "OK";
}
exports.validateIFillDetailsMetadata = validateIFillDetailsMetadata;
function isBoolean(arg) {
    return typeof arg === "boolean";
}
function validateIRelayerMakerOrder(order) {
    const { marketHash, maker, totalBetSize, percentageOdds, expiry, apiExpiry, executor, baseToken, salt, isMakerBettingOutcomeOne, } = order;
    if (!bytes_1.isHexString(marketHash)) {
        return "marketHash is not a valid hex string";
    }
    if (!address_1.isAddress(maker)) {
        return "maker is not a valid address";
    }
    if (!isPositiveBigNumber(totalBetSize)) {
        return "totalBetSize as a number is not positive";
    }
    if (!isPositiveBigNumber(percentageOdds)) {
        return "percentageOdds as a number is not positive";
    }
    const bigNumPercentageOdds = bignumber_1.BigNumber.from(percentageOdds);
    if (bigNumPercentageOdds.gte(constants_2.FRACTION_DENOMINATOR)) {
        return `percentageOdds must be less than ${constants_2.FRACTION_DENOMINATOR.toString()}`;
    }
    if (expiry !== 2209006800) {
        return "expiry incorrect";
    }
    if (apiExpiry <= Date.now() / 1000) {
        return "apiExpiry before current time.";
    }
    if (!address_1.isAddress(executor)) {
        return "executor is not a valid address";
    }
    if (!address_1.isAddress(baseToken)) {
        return "baseToken is not a valid address";
    }
    if (!isPositiveBigNumber(salt)) {
        return "salt as a number is not positive";
    }
    if (!isBoolean(isMakerBettingOutcomeOne)) {
        return "isMakingBettingOutcomeOne undefined or malformed.";
    }
    return "OK";
}
exports.validateIRelayerMakerOrder = validateIRelayerMakerOrder;
function validateISignedRelayerMakerOrder(order) {
    const baseValidation = validateIRelayerMakerOrder(order);
    if (baseValidation !== "OK") {
        return baseValidation;
    }
    const { signature } = order;
    if (!bytes_1.isHexString(signature)) {
        return "signature is not a valid hex string.";
    }
    return "OK";
}
exports.validateISignedRelayerMakerOrder = validateISignedRelayerMakerOrder;
function validateINewOrderSchema(order) {
    if (!isNonNegativeInteger(order.expiry)) {
        return "Expiry undefined or malformed.";
    }
    if (order.expiry < Date.now() / 1000) {
        return "Expiry before current time.";
    }
    if (!isPositiveBigNumber(order.totalBetSize)) {
        return "totalBetSize undefined or malformed.";
    }
    if (!isPositiveBigNumber(order.percentageOdds) ||
        bignumber_1.BigNumber.from(order.percentageOdds).gte(convert_1.convertToAPIPercentageOdds(1))) {
        return "impliedOdds must be between 0 and 1 exclusive.";
    }
    if (!bytes_1.isHexString(order.marketHash)) {
        return "marketHash undefined or malformed.";
    }
    if (typeof order.isMakerBettingOutcomeOne !== "boolean") {
        return "isMakerBettingOutcomeOne undefined or malformed.";
    }
    if (!address_1.isAddress(order.baseToken)) {
        return "baseToken undefined or malformed.";
    }
    return "OK";
}
exports.validateINewOrderSchema = validateINewOrderSchema;
function isNonNegativeInteger(input) {
    return Number.isInteger(input) && input >= 0;
}
/**
 * Checks if an object is a ethers.BigNumber and greater than zero
 * Implicitly checks if the object is undefined.
 * @param object Any object
 */
function isPositiveBigNumber(object) {
    try {
        const bigNumber = bignumber_1.BigNumber.from(object);
        return bigNumber.gt(constants_1.Zero);
    }
    catch (e) {
        return false;
    }
}
exports.isPositiveBigNumber = isPositiveBigNumber;
//# sourceMappingURL=validation.js.map